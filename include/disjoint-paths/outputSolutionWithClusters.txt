template<class T>
inline std::vector<size_t> Data<T>::outputSolution(std::vector<double>& intervalLabels,bool isIntervals){

	std::vector<std::vector<size_t>> paths=pathsFromSolution(intervalLabels);
	std::vector<size_t> labels(pGraph->numberOfVertices(),0);

	std::ofstream file;
	if(isIntervals){
		file.open(parameters.getOutputFileName() + "-all-paths-INTERVALS.txt");
	}
	else{
		file.open(parameters.getOutputFileName() + "-all-paths-FINAL.txt");
	}







	for (int i = 0; i < paths.size(); ++i) {
		for (int j = 0; j < paths[i].size(); ++j) {
			size_t v=paths[i][j];
			file<<v<<" ";
			labels[v]=i+1;
		}
		file<<std::endl;
	}
	file.close();








		std::string line;
		std::ifstream data(parameters.getGraphFileName());
		char delim=',';
		std::getline(data, line);
		double objValue=0;

		std::cout << "Read graph for better evaluation" << std::endl;
		std::vector<std::string> strings;


		std::cout<<"Reading vertices from file. "<<std::endl;
		//Vertices that are not found have score=0. Appearance and disappearance cost are read here.
		while (std::getline(data, line) && !line.empty()) {

		}

		std::map<size_t,std::map<size_t,double>> originalEdges;


		std::cout<<"Reading base edges from file. "<<std::endl;
		size_t maxLabel=0;
		while (std::getline(data, line) && !line.empty()) {

			strings = split(line, delim);

			unsigned int v = std::stoul(strings[0]);
			unsigned int w = std::stoul(strings[1]);
			if(v>numberOfVertices-3||w>numberOfVertices-3) continue;
			maxLabel=std::max(maxLabel,labels[v]);
			maxLabel=std::max(maxLabel,labels[w]);
			//if(v>=graph_.numberOfVertices()-2||w>=graph_.numberOfVertices()-2) continue;
			double score = std::stod(strings[2]);
			if(labels[v]!=0&&labels[v]==labels[w]){
				originalEdges[v][w]=score;
				objValue+=score;
			}
		}


		//objValue+=maxLabel*parameters.getInputCost()+maxLabel*parameters.getOutputCost();

		data.close();




		double inOutCost=parameters.getInputCost()+parameters.getOutputCost();

		for (int i = 0; i < paths.size(); ++i) {
			std::map<size_t,double> timeBrakes;
			std::map<size_t,double> origTimeBrakes;
			for (int j = 0; j < paths[i].size()-1; ++j) {
				size_t v=paths[i][j];
				size_t w=paths[i][j+1];
				size_t time=getGroupIndex(v);
				auto findEdge=pGraph->findEdge(v,w);
				if(!findEdge.first){
					throw std::runtime_error(std::string("wrong connection"));
				}
				else{
					timeBrakes[time]=costs[getEdgeVarIndex(findEdge.second)];
					//origTimeBrakes[time]=costs[getEdgeVarIndex(findEdge.second)];
					origTimeBrakes[time]=0;
				}
			}

			for (int j = 0; j < paths[i].size()-1; ++j) {
				size_t v=paths[i][j];
				size_t timeV=getGroupIndex(v);
				for (int k = j+1; k < paths[i].size()-1; ++k) {
					size_t w=paths[i][k];
					auto findLiftedEdge=pGraphLifted->findEdge(v,w);
					size_t timeW=getGroupIndex(w);
					if(findLiftedEdge.first){
						size_t edge=findLiftedEdge.second;
						double edgeCost=costs[getLiftedEdgeVarIndex(edge)];
						for (int t = timeV; t < timeW; ++t) {
							if(timeBrakes.count(t)>0){
								timeBrakes[t]+=edgeCost;
//								if(i==47&&t==338){
//									std::cout<<"edge "<<v<<","<<w<<": "<<edgeCost<<std::endl;
//								}
							}
						}

					}
					if(originalEdges[v].count(w)>0){
						for (int t = timeV; t < timeW; ++t) {
							if(origTimeBrakes.count(t)>0){
								origTimeBrakes[t]+=originalEdges[v][w];

							}
						}

					}
				}
			}

			//std::cout<<"check track "<<i<<std::endl;
			for(auto tB:timeBrakes){
				if(tB.second>inOutCost){
					std::cout<<"Wrong track "<<i<<" better cut in time "<<tB.first<<"cost"<<tB.second<<std::endl;
				}
			}
			for(auto tB:origTimeBrakes){
				if(tB.second>inOutCost){
					std::cout<<"Not good track "<<i<<" better cut in time "<<tB.first<<"cost"<<tB.second<<std::endl;
				}
			}
			//std::cout<<std::endl;

		}




		return labels;

}
